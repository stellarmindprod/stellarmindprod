Database Setup Notes for StellarMind Prod

This document outlines necessary database table structures and important considerations based on the Flask conversion requirements and old project files.

1. Tables from Provided SQL (Ensure these exist in your NEW Supabase):

b1, b2, b3, b4 (Student Info)

teachers

courses

grades

backlogs

marks1, marks2, marks3, marks4

2. Additional Tables Required (Create these in your NEW Supabase):

admins Table: Needed for admin login.

CREATE TABLE admins (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL, -- STORE HASHED PASSWORDS HERE!
    -- Add other admin details if needed (e.g., name, email)
    created_at TIMESTAMPTZ DEFAULT now()
);
-- Add an initial admin user (replace 'hashed_password_for_admin' with actual hash)
-- Example using generate_password_hash('your_admin_password') in Python:
-- INSERT INTO admins (username, password) VALUES ('admin', 'pbkdf2:sha256:...');


attendance Table: Based on stellarmindnitsikkim/stellarmind/stellar/sql.txt. Adapt as necessary.

CREATE TABLE attendance (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username TEXT NOT NULL,              -- student roll no (e.g., b240001)
    student_name TEXT,                   -- student full name (optional, can join)
    branch TEXT NOT NULL,                -- branch like CSE
    date DATE NOT NULL,
    status INTEGER NOT NULL DEFAULT 0,       -- number of classes attended that day
    total_classes INTEGER NOT NULL DEFAULT 1,-- total classes conducted that day
    subject_code TEXT NOT NULL,          -- subject unique identifier (FK to courses?)
    subject_name TEXT,                   -- subject name (optional, can join)
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Ensure one record per student per subject per day
CREATE UNIQUE INDEX unique_attendance_record
ON attendance (username, date, subject_code);

-- Optional: Trigger function to auto-update `updated_at` column
-- (Supabase might handle this automatically or provide UI options)
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
NEW.updated_at = NOW();
RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_attendance_updated_at
BEFORE UPDATE ON attendance
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();


events Table: Based on stellarmindnitsikkim/stellarmind/stellar/events/index.html functionality.

CREATE TABLE events (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    date DATE NOT NULL,
    time TIME, -- Optional time
    description TEXT, -- Optional description
    created_at TIMESTAMPTZ DEFAULT now()
);


holidays Table: Based on stellarmindnitsikkim/stellarmind/stellar/events/index.html functionality.

CREATE TABLE holidays (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    date DATE NOT NULL UNIQUE, -- Ensure only one holiday per date
    created_at TIMESTAMPTZ DEFAULT now()
);


3. CRITICAL: Password Security

Hashing is Mandatory: Storing passwords in plain text is a major security risk. You MUST store hashed passwords.

Flask Hashing: Use werkzeug.security.

To generate a hash (e.g., during signup or migration): from werkzeug.security import generate_password_hash; hashed_pw = generate_password_hash('the_plain_password')

To check a hash (during login): from werkzeug.security import check_password_hash; is_correct = check_password_hash('hashed_pw_from_db', 'password_from_login_form')

Database Update:

Change the data type of student_password (in b1..b4), teacher_password (in teachers), parent_password (in b1..b4 if used), and password (in admins) columns to TEXT. This accommodates the longer hashed password strings.

Migration Script: Create a separate Python script (migrate_passwords.py) that connects to your Supabase database (you might need psycopg2-binary installed: pip install psycopg2-binary supabase-py), reads the plain text passwords, generates hashes using generate_password_hash, and updates the corresponding rows. Run this script ONCE on your NEW database before enabling login in the Flask app.

Example Migration Snippet (Conceptual - adapt with your DB connection):

# Conceptual migrate_passwords.py snippet
# Needs proper Supabase client setup (e.g., using supabase-py)
from werkzeug.security import generate_password_hash
# from supabase import create_client, Client # Example using supabase-py
# supabase: Client = create_client(SUPABASE_URL, SUPABASE_SERVICE_KEY)

tables_to_update = {
    "b1": "student_password", "b2": "student_password", "b3": "student_password", "b4": "student_password",
    "teachers": "teacher_password",
    "admins": "password"
}
id_columns = { # Primary key or unique identifier for each table
     "b1": "id", "b2": "id", "b3": "id", "b4": "id",
     "teachers": "teacher_id", # Assuming teacher_id is PK
     "admins": "id"
}

for table, pw_col in tables_to_update.items():
    print(f"Processing table: {table}")
    # response = supabase.table(table).select(f"{id_columns[table]}, {pw_col}").execute() # Fetch ID and plain password
    # if response.data:
    #     for user in response.data:
    #         user_id = user[id_columns[table]]
    #         plain_password = user[pw_col]
    #         if plain_password and not plain_password.startswith('pbkdf2:'): # Check if not already hashed
    #             hashed_password = generate_password_hash(plain_password)
    #             print(f"  Updating ID {user_id}...")
    #             # update_response = supabase.table(table).update({pw_col: hashed_password}).eq(id_columns[table], user_id).execute()
    #             # Add error handling for update_response
    #         else:
    #             print(f"  Skipping ID {user_id} (already hashed or no password).")
print("Password migration finished.")


Code Adjustment: After migrating passwords in the database, modify the fetch_and_verify_user function in app.py. Replace the plain text comparison (== password) with check_password_hash(user_data.get('password_column_name', ''), password).

4. Supabase Row Level Security (RLS)

With the backend handling most operations, review your RLS policies.

If using SERVICE_ROLE_KEY (Recommended for Backend): This key bypasses RLS. Ensure your Flask application correctly implements authorization checks (e.g., using the @login_required(role='teacher') decorator) to prevent unauthorized actions.

If using ANON_KEY: Your RLS policies must explicitly grant SELECT, INSERT, UPDATE, DELETE permissions to the anon role for the tables your Flask app needs to access. This is generally more complex to manage for backend access.

5. Indexes:

Ensure indexes exist on columns used for lookups (username, roll_no, email) and frequently filtered columns (date, subject_code in attendance). Supabase usually adds indexes for Primary Keys and UNIQUE constraints automatically. Add others manually if needed via the Supabase SQL editor.